#!/bin/bash
set -e

# Statics
_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/"
red=`tput setaf 1`; green=`tput setaf 2`; yellow=`tput setaf 3`; blue=`tput setaf 4`; magenta=`tput setaf 5`; bow=`tput setaf 0;tput setab 7`; reset=`tput sgr0`; hk="${blue})${reset}"; undl=`tput smul`; bold=`tput bold`;
usage() { echo -e "Usage: $(basename "$0") [-d] [-q QuickConnect]\n\n    -d        Debug\n    -q <qc>   QuickConnect" 1>&2; exit 1; }

# getopts
P_QUICK=false
P_DEBUG=false
while getopts "q: d" o; do
    case "${o}" in
        d) P_DEBUG=true ;;
        q) P_QUICK="$OPTARG" ;;
        *) usage ;;
    esac
done
shift $(($OPTIND - 1))
([[ "${P_QUICK}" == false ]] && [ ! -z "$1" ]) && P_QUICK="$1"

#
#       exitByError
#       Shows error and dies
#       $! --> 1
#
function exitByError() {
    echo -e "\n${red}\n\t${@}${reset}\n"
    exit 1
}

#
#       _jq
#       Decodes and search for json key/value
#       $1 --> json
#       $2 --> key
#
function _jq() {
    echo ${1} | base64 --decode | jq -r ${2}
}

#
#       validateInput
#       Validates user input
#       Skip's while loop if invalid
#
function validateInput() {

    # Catch 'b' to go back
    # TODO: Show 'special' options in last line?
    if [[ $input == "b" ]]; then

        # Max 1 return
        if [ "$last_while_obj" != "$previous_while_obj" ]; then
            last_while_obj="${previous_while_obj}"
            ((depth--))
            continue
        else
            continue
        fi
    fi

    # Only allow 0-9
    re='^[0-9]+$'
    if ! [[ $input =~ $re ]]; then
        echo -e "\n${red}Invalid response!${reset}"
        continue
    fi
}

#
#       connectToServer()
#       Create and execute command
#       Use $f_s as server json
#
function connectToServer() {

    # Get server data, use default by null
    to_ip=$(echo "$f_s" | jq -r ".ip")
    to_key=$(echo "$f_s" | jq -r ".sshkey // false")
    to_port=$(echo "$f_s" | jq -r ".port // ${b_port}")
    to_user=$(echo "$f_s" | jq -r ".user // \"${b_user}\"")
    to_rsub=$(echo "$f_s" | jq -r "select(.rsub != false) | .rsub // \"${b_rsub}\"")
    to_gpg=$(echo "$f_s" | jq -r "select(.gpg != false) | .gpg // \"${b_gpg}\"")

    # Ensure ip is found
    [[ "$to_ip" == '' ]] && exitByError 'Invalid ip'

    # Create cmd, start with rsub
    [[ ! -z $to_rsub && "$to_rsub" != false ]] && TO_CMD="-R ${to_rsub}:localhost:${to_rsub}"

    # Add ssh-key
    [[ "${to_key}" != false ]] && TO_CMD=" -i ${to_key}"

    # Add 'ssh', port, user and ip
    TO_CMD="ssh -A ${TO_CMD} -p ${to_port} ${to_user}@${to_ip}"

    # Get gpg data

    # Print '--' if depth > 0
    [[ "$depth" -gt "0" ]] && echo -e "\n${prefix}  ---------"

    # Print
    cat << EOF

${undl}Connecting...${reset}
${bold}$(echo "$f_s" | jq -r ".name // \"--\"")${reset}
${green}${to_user}${reset}${bold}@${reset}${yellow}${to_ip}${reset}${bold}:${reset}${green}${to_port}${reset}
EOF

    # Check debug state
    if [ "${P_DEBUG}" != false ]; then
        echo -e "\n    +-------+\n    | ${red}Debug${reset} |\n    +-------+"
    else

        # Run ssh command
        $TO_CMD
    fi

    # We're done!
    exit 0
}

# Check JQ dependency
hash "jq" 2>/dev/null || { printf >&2 "\n${red}\n\tDependency error!${reset}\n\n\tsoSsh requires ${bold}jq{$reset} package!\n\n\t${green}Please install with ${bold}sudo apt install jq${green}!${reset}"; exit 2; }

# Ensure json file exists
if [ ! -f ~/.sossh ]; then
    echo -e "\n${red}\n\tNo config found!${reset}\n\n\n\t${green}Please create you local soSsh object at ${bold}~/.sossh${reset}\n"
    touch ~/.sossh
    exit 3
fi

# Read JSON
raw=`jq . ~/.sossh`

# Get some defaults
b_gpg=$(echo $raw | jq -r '.default.GPG // false')
b_port=$(echo $raw | jq -r '.default.port // 22')
b_user=$(echo $raw | jq -r '.default.user // "root"')
b_rsub=$(echo $raw | jq -r '.default.rsub // false')

# Check for a qc param
if [ "$P_QUICK" != false ]; then

    # Search and loop throug given QC
    qc=$(echo $raw | jq -r ".. | select(.qc? == \"${P_QUICK}\") // empty")

    # Not found
    [[ -z $qc ]] && exitByError "${bold}Q${reset}${red}uick-${bold}C${reset}${red}onnect #${bold}${P_QUICK}${reset} ${red}not found!"

    # Connect
    f_s="${qc}" && connectToServer
fi

# Ask for servers until we've reached the end
depth=1
reached_end=false
previous_while_obj=""
last_while_obj="$raw"
while [[ $reached_end == false ]]; do

    # Prefix
    prefin=$(( 4 * ${depth}))
    prefix=`printf %\ ${prefin}s|tr \  \ `

    # G
    has_g=$(echo "$last_while_obj " | jq ".g")
    if [[ "$has_g" != 'null' ]]; then

        # Show id & name of each group
        echo -e "\n${prefix}${green}Select${reset} ${undl}group${reset}:\n"
        for row in $(echo "$last_while_obj" | jq -r '.g[] | @base64'); do
            echo -e "${prefix}    $(_jq $row '.id')${hk}  $(_jq $row '.name')"
        done

        # Read input && search for matching group id
        read -sn1 input && validateInput
        f_tmp=`echo ${last_while_obj} | jq ".g[]  | select(.id == ${input})"`

        # Retry or continue
        if [[ -z $f_tmp ]]; then
            echo -e "\n${red}${bold}Group${reset}${red} not found!${reset}"
            continue
        else
            ((depth++))
            previous_while_obj="$last_while_obj" && last_while_obj="$f_tmp"
            continue
        fi
    fi

    # S
    has_s=$(echo "$last_while_obj " | jq ".s")
    if [[ "$has_s" != 'null' ]]; then

        # Show id & name of each server
        echo -e "\n${prefix}${green}Select${reset} ${bold}$(echo "$last_while_obj" | jq -r ".name ")${reset} ${undl}server${reset}:\n"
        for row in $(echo "$last_while_obj" | jq -r '.s[] | @base64'); do
            echo -e "${prefix}    $(_jq $row '.id')${hk} $(_jq $row '.name')"
        done

        # Read input & get matching server
        read -sn1 input && validateInput
        f_tmp=$(echo "$last_while_obj" | jq -r ".s[] | select(.id == ${input})")

        # Retry or continue
        [[ -z $f_tmp ]] && echo -e "\n${red}${bold}Server${reset}${red} not found!${reset}" && continue

        # T
        has_t=$(echo "${f_tmp}" | jq ".t")
        if [[ ! -z $has_t && "$has_t" != '' && "$has_t" != null ]]; then

            # Remember base_name and base_user
            g_b_name=$(echo $f_tmp | jq '.name')
            g_b_ip="$(echo $f_tmp | jq '.ip')"

            # Create clean group name
            g_b_name_c="${g_b_name%\"}" && g_b_name_c="${g_b_name_c#\"}"
            g_b_name_c=$(echo ${g_b_name_c/\?\?/${red}X${reset}})

            # For .t times
            echo -e "\n${prefix}    ${green}Select${reset} ${bold}${g_b_name_c}${reset} ${undl}server${reset}:\n"
            for (( i = 0; i < has_t; i++ )); do

                # Create h_i (++)
                t_i=$i
                h_i=$(expr $t_i \+ 1)

                # Remove quotes
                t_ip="${g_b_ip%\"}" && t_ip="${t_ip#\"}"
                t_name="${g_b_name%\"}" && t_name="${t_name#\"}"

                # Replace '??' --> $i
                t_ip=$(echo ${t_ip/\?\?/$h_i})
                t_name=$(echo ${t_name/\?\?/$h_i})
                echo -e "${prefix}        ${h_i}${hk} ${t_name} ($t_ip)"
            done

            # Read and validate input until valid
            t_w_r=false; while [[ $t_w_r == false ]]; do
                read -sn1 input && validateInput
                if [[ "$input" -lt "0" ]] || [[ "$input" -gt "$has_t" ]]; then
                    # Retry
                    echo -e "\n${red}${bold}Server #${input}${reset}${red} not found!${reset}\n"
                    continue
                fi
                t_w_r=true
            done

            # Replace ?? with number
            f_ip=$(echo ${g_b_ip/\?\?/$input})
            f_name=$(echo ${g_b_name/\?\?/$input})

            # Set $f_s to custom object
            f_s="{ \"id\": ${has_t}, \"user\": $(echo $f_tmp | jq '.user'), \"name\": ${f_name}, \"ip\": ${f_ip}, \"rsub\": \"false\" }"
            reached_end=true
            ((depth++)) && continue
        fi

        # Ssh-server
        f_s="$f_tmp" && reached_end=true
    fi
done

# Connect
connectToServer
